 Life cycle order of the angular component. 
1. Constructor → Dependency injection only
2. ngOnChanges() → First call if @Input() properties exist [web:25]
3. ngOnInit() → Initialize data, one-time setup 
4. ngDoCheck() → Custom change detection (runs often)
5. ngAfterContentInit() → Content children ready
6. ngAfterContentChecked() → Content checked
7. ngAfterViewInit() → ViewChild/children accessible [web:64]
8. ngAfterViewChecked() → View checked
9. ngOnDestroy() → Cleanup before destruction


No @Input(): Constructor → ngOnInit
With @Input(): Constructor → ngOnChanges → ngOnInit → ...

So ngOnChanges will run only if there is an input property and it contains at least one changes inside it 

@ViewChild provides a direct reference to a child component instance, allowing access to its public methods 
(e.g., this.popover.open()) and properties from the parent after ngAfterViewInit.

when we do not define any acess modifier then it will be treated as public by default













API data stays in 1 component? → ngOnInit ✅
Data needed by 2+ components? → Effects ✅
